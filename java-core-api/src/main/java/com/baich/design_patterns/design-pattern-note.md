# 模式分类
##创建型模式
    这些设计模式提供了一种再创建对象的同事隐藏常见逻辑的方式，而不是使用new 运算符直接实例化对象，这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。
### 工厂模式 (Factory Pattern)
    定义一个用于创建产品的接口，由子类决定生产什么产品。
### 抽象工厂模式 (Abstract Factory Pattern)
    提供一个用于创建产品族的接口，其每个子类可以生产一系列相关的产品。
### 单例模式 (Singleton Pattern)
    某个类只能生成一个实例，该类提供了一个全局访问点供外部获取改实例，其拓展是有限多例模式。
### 建造者模式 (Builder Pattern)
    将一个复杂对象分解成多个相对简单的部分，然后根据不同需求分别创建它们，最后构建成该复杂对象。
### 原型模式 (Prototype Pattern)
    将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

## 结构型模式
    这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。
###  适配器模式 (Adapter Pattern)
    将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
###  桥接模式 (Bridge Pattern)
    将抽象与实现分离，使它们可以独立变化。它是用组合关系继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
###  组合模式 (Composite Pattern)
    将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。    
###  装饰器模式 (Decorator Pattern)
    动态的给对象增加一些职责，即增加其额外的功能。
###  外观模式 (Facade Pattern)
    为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
### 享元模式 (Flyweight Pattern)
    运用共享技术来有效的支持大量细粒度对象的复用。
### 代理模式 (Proxy Pattern)
    为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。

## 行为型模式
    这些设计模式特别关注对象之间的通信
### 责任链模式 (Chain of Responsibility Pattern)
    把请求从链中的一个对象传到下一个对象，直到请求被响应为止，通过这种方法去除对象之间的耦合。
### 命令模式 (Command Pattern)
    将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。
### 解释器模式 (Interpreter Pattern)
    提供如何定义语言的文法，以及对语言句子的解释方法。
### 迭代器模式 (Iterator Pattern)
    提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
### 中介者模式 (Mediator Pattern)
    定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必互相了解。
### 备忘录模式 (Memento Pattern)
    在波破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
### 观察者模式 (Observer Pattern)
    在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知并自动更新。
### 状态模式 (State Pattern)
    允许一个对象在其内部状态发生改变时改变其行为能力。
### 策略模式 (Strategy Pattern)
    定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
### 模板模式 (Template Pattern)
    定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
### 访问者模式 (Visitor Pattern)
    在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

# 类之间的关系
## 依赖 (Dependency)
    依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，时临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。
## 关联 (Association)
    关联关系时对象之间的一种引用关系，用于表示一类对象与另一类对象之间的联系。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。
## 聚合 (Aggregation)
    聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系(has-a)。
## 组合 (Composition)
    组合关系是关联关系的一种，也表示类之间的整体与部分的关系，是一种更强烈的聚合关系(contain-a)。组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。
## 泛化 (Generalization)
    泛化关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，父类与子类之间的关系，继承关系(is-a)。
## 实现 (Realization)
    实现关系是接口与实现类之间的关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。
    
# 七大原则[一句话概括](七大原则.png)
    记忆口诀：访问加限制，函数要节俭，依赖不允许，动态加接口，父类要抽象，扩展不更改。
## 开闭原则
    Open Closed Principle, OCP 软件实体应当对扩展开放，对修改关闭。
## 里氏替换原则
    Liskov Substitution Principle, LSP 继承必须确保超类所拥有的性质在子类中仍然成立。
## 依赖倒置原则
    Dependence Inversion Principle, DIP 高层模块不应该依赖低层模块，两者都应该依赖其抽象，抽象不应该依赖细节，细节应该依赖抽象。核心思想是：面对接口编程，不要面向实现编程。
## 单一职责原则
    Single Responsibility Principle, SRP 一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
## 接口隔离原则
    Interface Segregation Principle, ISP 客户端不应该被迫依赖于它不使用的方法。
## 迪米特法则
    Law of Demeter, LoD 如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
## 合成复用原则
    Composite Reuse Principle，CRP 在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。