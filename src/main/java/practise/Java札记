1、Long.valueOf()与Long.parseLong()：
    1.8的源码显示
    1) 如果入参为字符串，Long.valueOf()的返回为：return Long.valueOf(parseLong(s, 10));
       也就是说会先调用一次parseLong，所以效率上来讲，Long.parseLong()是高于Long.valueOf()的
    2) 如果入参为一个数（二进制、八进制、十进制等类型），Long.valueOf()调用的LongCache缓存机制会提升效率（缓存命中），
       这比调用Long.parseLong()（需要先将入参转为字符串）效率更高
    3) 从返回结果方面考虑，Long.valueOf()返回的是Long类型，而Long.parseLong()返回的是long类型，
       所以如果抛开缓存命中机制的话，Long.parseLong()的效率更胜一筹。

2、static
    1) 当static修饰类变量时，如果该变量是public的话，表示该变量任何类都可以直接访问，而且无需初始化类，
       直接使用类名.static 变量 这种形式访问即可。
    2) 当static修饰方法时，代表该方法和类实例（对象）无关，任何类都可以直接访问（如果权限是public的话）。
       该方法内部也只能调用static修饰的方法
    3) static修饰代码块后，代码块变为静态代码块，常常用于类启动之前，初始化一些值。
    4) 被static修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被初始化

3、final
    1) 被final修饰的类，表明该类是无法继承的；
    2) 被final修饰的方法，表明该方法是无法覆写的；
    3) 被final修饰的变量，说明该变量在声明的时候就必须初始化完成，而且以后也不能修改起内存地址。

4、volatile
    常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，
    其他线程就能知道当前共享变量的值已经被修改。

5、transient
    常用来修饰类变量，意思是当前变量是无需进行序列化的，在序列化时就会忽略该变量。

6、default
    一般用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现

7、ArrayList
    底层设计为简单数组
    DEFAULT_CAPACITY：新建一个ArrayList，不传入initialCapacity时走无参构造，此时列表的初始容量为0，当执行add的时候才会进行扩容
    size：表示ArrayList的大小，类型为int，没有使用 volatile 修饰，非线程安全
    modCount：统计当前数组被修改的版本次数，数组结构有变动，就会+1
    根据源码类描述，有：
        1) 允许put null值，会自动扩容；
        2) size isEmpty get set add等方法时间复杂度都是O(1);
        3) 是非线程安全的，多线程情况下推荐使用线程安全类
        4) 增强for循环，或者使用迭代器迭代过程中，如果大小被改变，会快速失败，抛出异常。
    方法注释：
        1) 扩容是后的大小是原来容量的1.5倍
        2) ArrayList中列表的最大值是Integer.MAX_VALUE, 超过这个值，JVM就不会给数组分配内存空间了
        3) 新增时，没有对值进行严格较验，也是允许null值的
8、LinkedList
    底层数据结构是一个双向链表
    只要机器内存足够强大，是没有大小限制的。
    链表中的元素叫做Node

    hash值 % n(数组大小) == (n-1) & hash

9、Set API其实就是对Map API的组合。巧妙利用了Map的结构特点
   初始容量（大小）= max((期望的值/0.75 + 1),16)

10、集合的坑：
    1) 当集合的元素是自定义类时，自定义类强制实现equals和hashCode方法，并且两个都要实现。
    2) 所有集合类，在for循环进行删除时，直接使用集合类的remove方法进行删除会报ConcurrentModificationException错误，所以任意循环删除的场景下，最好用迭代器进行删除。
    3) 数组转化为集合时，使用的Arrays.asList(array),这个方法有两个坑：
       -- 数组被修改后，会直接影响到新List的值
       -- 不能对新List进行add、remove等操作，否则会报UnsupportedOperationException错误
          形成原因是Arrays.asList方法返回的List并不是java.util.ArrayList,而是自己内部的一个静态类，该静态类直接持有数组的引用，并且没有实现add、remove等方法
    4) 集合List转化为数组，通常使用的toArray方法，如果申明的数组大小小于List的大小的话，会得到一个元素均为null的数组。

11、并发List、Map使用最多的是CopyOnWriteArrayList和ConcurrentHashMap，这两个并发类在安全和性能方面都很好
12、链表阻塞队列LinkedBlockingQueue底层数据结构是链表，并且队列是可阻塞的。

13、Spark SQL的性能优化技术：
    1) 内存列存储(in-memory columnar storage)
       Spark SQL不使用Java对象的方式进行存储，而是使用面向列的内存存储的方式进行存储。每一列作为一个数据存储的单位
       从而大大优化了内存使用的效率。减少了对内存的消耗，也避免了gc大量数据的性能开销。
    2) 字节码生成技术(byte-code generation)
       Spark SQL在其catalust模块的expressions中增加了codegen模块，对于SQL语句中的计算表达式，比如
       SELECT num+num FROM t这种sql，就可以使用动态字节码生成技术来优化其性能
    3) Scala代码编写的优化
       对于Scala代码的编写，可能会造成较大性能开销的地方，自己重写，使用更加复杂的方式来获取更好的性能