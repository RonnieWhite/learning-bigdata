1、Long.valueOf()与Long.parseLong()：
    1.8的源码显示
    1) 如果入参为字符串，Long.valueOf()的返回为：return Long.valueOf(parseLong(s, 10));
       也就是说会先调用一次parseLong，所以效率上来讲，Long.parseLong()是高于Long.valueOf()的
    2) 如果入参为一个数（二进制、八进制、十进制等类型），Long.valueOf()调用的LongCache缓存机制会提升效率（缓存命中），
       这比调用Long.parseLong()（需要先将入参转为字符串）效率更高
    3) 从返回结果方面考虑，Long.valueOf()返回的是Long类型，而Long.parseLong()返回的是long类型，
       所以如果抛开缓存命中机制的话，Long.parseLong()的效率更胜一筹。

2、static
    1) 当static修饰类变量时，如果该变量是public的话，表示该变量任何类都可以直接访问，而且无需初始化类，
       直接使用类名.static 变量 这种形式访问即可。
    2) 当static修饰方法时，代表该方法和类实例（对象）无关，任何类都可以直接访问（如果权限是public的话）。
       该方法内部也只能调用static修饰的方法
    3) static修饰代码块后，代码块变为静态代码块，常常用于类启动之前，初始化一些值。
    4) 被static修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被初始化

3、final
    1) 被final修饰的类，表明该类是无法继承的；
    2) 被final修饰的方法，表明该方法是无法覆写的；
    3) 被final修饰的变量，说明该变量在声明的时候就必须初始化完成，而且以后也不能修改起内存地址。

4、volatile
    常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，
    其他线程就能知道当前共享变量的值已经被修改。

5、transient
    常用来修饰类变量，意思是当前变量是无需进行序列化的，在序列化是就会忽略该变量。

6、default
    一般用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现