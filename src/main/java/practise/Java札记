1、Long.valueOf()与Long.parseLong()：
    1.8的源码显示
    1) 如果入参为字符串，Long.valueOf()的返回为：return Long.valueOf(parseLong(s, 10));
       也就是说会先调用一次parseLong，所以效率上来讲，Long.parseLong()是高于Long.valueOf()的
    2) 如果入参为一个数（二进制、八进制、十进制等类型），Long.valueOf()调用的LongCache缓存机制会提升效率（缓存命中），
       这比调用Long.parseLong()（需要先将入参转为字符串）效率更高
    3) 从返回结果方面考虑，Long.valueOf()返回的是Long类型，而Long.parseLong()返回的是long类型，
       所以如果抛开缓存命中机制的话，Long.parseLong()的效率更胜一筹。

2、static
    1) 当static修饰类变量时，如果该变量是public的话，表示该变量任何类都可以直接访问，而且无需初始化类，
       直接使用类名.static 变量 这种形式访问即可。
    2) 当static修饰方法时，代表该方法和类实例（对象）无关，任何类都可以直接访问（如果权限是public的话）。
       该方法内部也只能调用static修饰的方法
    3) static修饰代码块后，代码块变为静态代码块，常常用于类启动之前，初始化一些值。
    4) 被static修饰的方法，在类初始化的时候并不会初始化，只有当自己被调用时，才会被初始化

3、final
    1) 被final修饰的类，表明该类是无法继承的；
    2) 被final修饰的方法，表明该方法是无法覆写的；
    3) 被final修饰的变量，说明该变量在声明的时候就必须初始化完成，而且以后也不能修改起内存地址。

4、volatile
    常用来修饰某个共享变量，意思是当共享变量的值被修改后，会及时通知到其它线程上，
    其他线程就能知道当前共享变量的值已经被修改。

5、transient
    常用来修饰类变量，意思是当前变量是无需进行序列化的，在序列化时就会忽略该变量。

6、default
    一般用在接口的方法上，意思是对于该接口，子类是无需强制实现的，但自己必须有默认实现

7、ArrayList
    底层设计为简单数组
    DEFAULT_CAPACITY：新建一个ArrayList，不传入initialCapacity时走无参构造，此时列表的初始容量为默认值10，空列表
    size：表示ArrayList的大小，类型为int，没有使用 volatile 修饰，非线程安全
    modCount：统计当前数组被修改的版本次数，数组结构有变动，就会+1
    根据源码类描述，有：
        1) 允许put null值，会自动扩容；
        2) size isEmpty get set add等方法时间复杂度都是O(1);
        3) 是非线程安全的，多线程情况下推荐使用线程安全类
        4) 增强for循环，或者使用迭代器迭代过程中，如果大小被改变，会快速失败，抛出异常。
    方法注释：
        1) 扩容是后的大小是原来容量的1.5倍
        2) ArrayList中列表的最大值是Integer.MAX_VALUE, 超过这个值，JVM就不会给数组分配内存空间了
        3) 新增时，没有对值进行严格较验，也是允许null值的
8、LinkedList
    底层数据结构是一个双向链表
    只要机器内存足够强大，是没有大小限制的。
    链表中的元素叫做Node